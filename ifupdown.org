#+TITLE: ifupdown : Interface Tools
#+AUTHOR: Anthony Towns (aj@azure.humbug.org.au)
#+OPTIONS: todo:t ^:nil

#+BEGIN_QUOTE
Copyright \copyright\ 1999--2007 Anthony Towns. This program is free
software; you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software
Foundation; either version 2 of the License, or (at your option) any
later version.  
#+END_QUOTE

* Introduction

This source defines the commands [[ifup]], [[ifdown]], and [[ifquery]], used
to manipulate interfaces in an easily controllable manner.

** Assumed Knowledge

The reader is assumed to have knowledge of the C \cite{K&R} and Perl
\cite{camel} programming languages in a Unix environment \cite{StevensUnix}.
A cursory understanding of network administration on the appropriate
platform is also assumed, along with access to the relevant manual
pages as necessary.

This source has been written as a literate program using the [[noweb]]
\cite{wwwnoweb} tool suite, and typeset using \LaTeX\ \cite{latex}.

** Program Structure

We shall decompose this program into four main areas of functionality:

- compile-time configuration
- run-time configuration
- execution
- and the overall driver

Compile-time configuration will deal with differing available address
families (IP vs IPX vs IPv6, and so on), and the differing methods of
enabling and disabling interfaces configured for each family. This will
be implemented using the [[addrfam]] module, and various [[.defn]] files,
for the address family definitions.

Run-time configuration will deal with determining the local setup
based on the file [[/etc/network/interfaces]], and producing a data
structure encapsulating these details. This will be implemented in the
[[config]] module.

Execution will deal with issues relating to working out exactly which
commands to run based on a somewhat abstract description from the
compile-time configuration and the details determined at
run-time. This will be dealt with in the [[execute]] module.

The remaining work --- argument parsing, error reporting, and,
essentially, putting all the pieces together --- is done by the
[[main]] module.

The following diagram gives a brief idea of the information and control
flow amongst the modules.

# How to generate?

#+BEGIN_SRC tex
\def\vsep{2.5cm}
\def\hsep{1.4cm}
\begin{figure}
\centering
\begin{tikzpicture}[every text node part/.style={text centered}]
    \tikzstyle{block}=[rectangle,draw, text width=2cm, minimum height=2cm]
    \tikzstyle{big}=[minimum height=4.5cm]
    \tikzstyle{annot}=[above left]

    \node[block] (ip) at (0,0) {IP address family};
    \node[annot] at (ip.south east) {\small inet.defn};

    \node[block] (ipx) at (0,-\vsep) {IPX address
    family};
    \node[annot] at (ipx.south east) {\small inet.defn};

    \node[block,big] (addrfam) at (\hsep*2,-\vsep/2) {Compile time configuration};
    \node[annot] at (addrfam.south east) {\small addrfam.c};

    \node[block,big] (config) at (\hsep*4,-\vsep/2) {Runtime configuration};
    \node[annot] at (config.south east) {\small config.c};

    \node[block] (exec) at (\hsep*6,0) {Execution};
    \node[annot] at (exec.south east) {\small execute.c};

    \node[block] (main) at (\hsep*6,-\vsep) {Driver};
    \node[annot] at (main.south east) {\small main.c};

    \draw[-stealth] (ip.east) -- (addrfam.west |- ip);
    \draw[-stealth] (ipx.east) -- (addrfam.west |- ipx);
    \draw[-stealth] (addrfam) -- (config);
    \draw[stealth-] (exec.west) -- (config.east |- exec);
    \draw[stealth-] (main.west) -- (config.east |- main);
    \draw[-stealth] (main) -- (exec);

    \node[below=1.2cm of config.south] (mainf) {main()};

    \draw[-stealth, rounded corners=0.3cm] (mainf) -- +(0,1cm) -| (main.south);
\end{tikzpicture}
\end{figure}
#+END_SRC

Much of the information sharing will be done by defining and filling
in some data structures and allowing the other modules to just access
that information directly. Rather than hiding the information itself,
most of our modules simply attempt to hide how that information was
originally written. Because of this, we shall find that these modules are
too closely linked to be completely separated in a convenient manner,
so they will all make use of a single header file for each other's
structure definitions, exported interfaces and so on.

#+BEGIN_SRC C :mkdirp true :tangle src/header.h
#ifndef HEADER_H
#define HEADER_H

#include <stdbool.h>

<<type definitions>>
<<function type definitions>>
<<structure definitions>>
<<constant definitions>>
<<exported symbols>>
<<address family declarations>>

#endif /* HEADER_H */

#+END_SRC

* The Build System

We shall begin with the template for the Makefile we shall use.

#+BEGIN_SRC conf :mkdirp true :tangle src/Makefile 

<<make options>>
ARCH ?= linux

BASEDIR ?= $(DESTDIR)

CFILES := addrfam.c execute.c config.c main.c arch$(ARCH).c
HFILES := header.h arch$(ARCH).h
PERLFILES := defn2c.pl defn2man.pl
DEFNFILES := inet.defn ipx.defn inet6.defn can.defn

OBJ := main.o addrfam.o execute.o config.o \
	$(patsubst %.defn,%.o,$(DEFNFILES)) arch$(ARCH).o meta.o link.o

MAN := $(patsubst %.defn,%.man,$(DEFNFILES))
DEFNFILES += meta.defn link.defn

default : executables
all : executables docs

executables : ifup ifdown ifquery ifup.8 ifdown.8 ifquery.8 interfaces.5
docs : ifupdown.ps.gz ifup.8.ps.gz interfaces.5.ps.gz ifupdown.pdf

.PHONY : executables 
<<phony targets>>
<<executable targets>>
<<manpage targets>>
<<extra dependencies>>
<<implicit rules>>

<<generated dependency inclusion>>

#+END_SRC

We shall build exactly three executables, [[ifup]], [[ifdown]] and
[[ifquery]], which will in truth simply be three names for a single binary,
albeit with different functionality.

#+BEGIN_SRC conf :noweb-ref executable targets
ifup: $(OBJ)
	$(CC) $(CFLAGS) $^ $(LDFLAGS) $(OUTPUT_OPTION)

ifdown: ifup
	ln -sf ifup ifdown

ifquery: ifup
	ln -sf ifup ifquery

#+END_SRC

All three of these executables have a manpage. Since they're actually the
same executable, what could be more appropriate than them having the
same manpage too?

#+BEGIN_SRC conf :noweb-ref manpage targets
interfaces.5: interfaces.5.pre $(MAN)
	sed $(foreach man,$(MAN),-e '/^##ADDRESSFAM##$$/r $(man)') \
	     -e '/^##ADDRESSFAM##$$/d' < $< > $@	

ifdown.8 ifquery.8: ifup.8
	ln -sf $< $@

%.5.ps: %.5
	groff -mandoc -Tps $< > $@
%.8.ps: %.8
	groff -mandoc -Tps $< > $@

#+END_SRC

Further, for convenience, we'll make use of two phony targets, [[clean]],
[[clobber]] and [[distclean]], which will delete working files, everything
that can be rebuilt with a [[make]] command, and everything that can be
rebuilt at all, respectively.

#+BEGIN_SRC conf :noweb-ref phony targets
.PHONY : clean clobber

install :
	install -m 0755 -d     ${BASEDIR}/sbin
	install -m 0755 ifup   ${BASEDIR}/sbin
	ln ${BASEDIR}/sbin/ifup ${BASEDIR}/sbin/ifdown	
	ln ${BASEDIR}/sbin/ifup ${BASEDIR}/sbin/ifquery

clean :
	rm -f *.aux *.toc *.log *.bbl *.blg *.ps *.eps *.pdf
	rm -f *.o *.d $(patsubst %.defn,%.c,$(DEFNFILES)) *~
	rm -f $(patsubst %.defn,%.man,$(DEFNFILES))
	rm -f ifup ifdown ifquery interfaces.5 ifdown.8 ifquery.8
	rm -f ifupdown.dvi *.ps{,.gz}

clobber : clean
	rm -f ifupdown.tex $(PERLFILES) $(CFILES) $(HFILES) $(DEFNFILES) arch*

distclean : clobber
	rm -f makecdep.sh makenwdep.sh Makefile

#+END_SRC

We have some fairly standard rules to build the printed version of the
source code using \LaTeX\ that are, unfortunately, not included in
[[make(1)]]'s builtin rules, so we'll note them here.

#+BEGIN_SRC conf :noweb-ref implicit rules
%.tex : %.nw
	noweave -delay -index -latex $< >$@

%.bbl : %.tex biblio.bib
	latex $<
	bibtex $(basename $<)

%.dvi : %.tex %.bbl
	latex $<
	latex $<

%.pdf : %.tex %.bbl
	pdflatex $<
	pdflatex $<

%.ps : %.dvi
	dvips -o $@ $<

%.gz : %
	gzip --best --stdout $< >$@

#+END_SRC

Additionally, some of [[make]]'s builtin rules are fairly
conservative, so we'll encourage it to use a more entertaining method
of compiling source code.

#+BEGIN_SRC conf :noweb-ref make options

VERSION ?= 0.7
CFLAGS ?= -Wall -W -g -O2 -D'IFUPDOWN_VERSION="$(VERSION)"'

#+END_SRC

** Graphics

We include a few graphics (made using dia) in this document. We have to
express these fairly explicitly, unfortunately.

#+BEGIN_SRC conf :noweb-ref implicit rules
%.eps : %.dia
	dia --nosplash -e $@ $<

%.pdf : %.eps
	gs -q -sDEVICE=pdfwrite -dNOPAUSE -sOutputFile=$@ - < $<

#+END_SRC

#+BEGIN_SRC conf :noweb-ref extra dependencies

ifupdown.dvi: modules.eps execution.eps
ifupdown.ps: modules.eps execution.eps
ifupdown.pdf: modules.pdf execution.pdf

#+END_SRC

** Automatic Dependencies

To build the system, we'll make use of some techniques discussed in
\cite{recursivemake} for determining dependencies. Namely, a number
of files will have an associated [[.d]] file containing dynamically
determined dependency information. The first such file we will construct
is the dependency information for [[noweb]] source files, which can be
identified by the [[.nw]] extension.

#+BEGIN_SRC conf :noweb-ref implicit rules

%.d: %.nw makenwdep.sh
	./makenwdep.sh $< > $@

#+END_SRC

To construct the dependency information, we may use the [[noroots(1)]]
command to determine the \emph{root chunks} in the [[noweb]] source
(stripping the unwanted [[<<]] and [[>>]] markers as we go, and
denoting that in such a way that [[noweb]] doesn't mistakenly think
the [[sed]] command is a chunk reference itself), and then noting down
appropriate commands to construct the target.

#+BEGIN_SRC conf :noweb-ref makenwdep arguments

<<parse makenwdep arguments>>

noroots $FILE | sed 's/^<''<\(.*\)>>$/\1/' |
	while read chunk; do
		<<output dependency info for [[$chunk]]>>
	done

#+END_SRC

Our dependency information is straightforward. To construct a file from
[[noweb]] source, we simply need to run [[notangle(1)]] over it. We add
a couple of extra tweaks in order to only update files that were actually
changed (the [[cpif(1)]] call), and to handle tabs properly.

We also need some extra things to take care of particular types of files.
In particular its important to have our scripts marked executable, so we
can use them as part of the build process itself, and it's also important
to have the dependency information for our C files (which are dealt with
next) included at some point.

#+BEGIN_SRC sh :noweb-ref output dependency info for [[$chunk]]
printf "%s : %s\n" "$chunk" "$FILE"
case $chunk in
	*.pl|*.sh)
		printf "\tnotangle -R\$@ \$< >\$@\n"
		printf "\tchmod 755 %s\n" "$chunk"
		;;
	*.c)
		printf "\tnotangle -L -R\$@ \$< | cpif \$@\n"
		printf "include ${chunk%.c}.d\n"
		;;
	*.h)
		printf "\tnotangle -L -R\$@ \$< | cpif \$@\n"
		;;
	*)
		printf "\tnotangle -t8 -R\$@ $< >\$@\n"
		;;
esac

#+END_SRC

Finally, our fairly primitive argument parsing is simply:

#+BEGIN_SRC sh :noweb-ref parse makenwdep arguments
FILE=$1

if [ "$FILE" = "" -o ! -f "$FILE" ]; then
	echo "Please specify a .nw file"
	exit 1
fi

#+END_SRC

We have a related system for object files generated from C source
code. Since each object file depends not only on its source, but also
the headers included in that source, we generate a [[.d]] file indicating
exactly which headers need to be checked.

#+BEGIN_SRC sh :noweb-ref implicit rules

%.d: %.c makecdep.sh
	./makecdep.sh $< > $@

#+END_SRC

We can do this using [[gcc(1)]]'s convenient [[-MM -MG]] options,
which do exactly this, with the added proviso that the [[.d]] file
itself can possibly depend on any of the header files being modified
(and, in particular, [[#include]] lines being added or deleted).

#+BEGIN_SRC sh :tangle makecdep.sh
#!/bin/sh
<<parse makecdep arguments>>

gcc -MM -MG $FILE |
  sed -e 's@^\(.*\)\.o:@\1.o \1.d:@'
@ 

\emph{Deja vu}, anyone?

<<parse makecdep arguments>>= 
FILE=$1
if [ "$FILE" = "" -o ! -f "$FILE" ]; then
	echo "Please specify a .c file"
	exit 1
fi
#+END_SRC

To include the generated dependencies in [[Makefile]], we have to
be a bit careful.  The problem here is that they should not be rebuild
when merely the cleaning of the source tree is asked for.  Any targets
ending in [[clean]], plus the [[clobber]] target prevent the inclusion
of the generated dependencies.

Unfortunately, [[make]] doesn't allow logical combinations within
[[ifeq]] and friends, so we have to simulate this.

#+BEGIN_SRC conf :noweb-ref generated dependency inclusion

include-deps := YES
ifneq "" "$(filter %clean,$(MAKECMDGOALS))"
include-deps := NO
endif
ifeq "clobber" "$(MAKECMDGOALS)"
include-deps := NO
endif

#+END_SRC

Finally, include the dependency information:

#+BEGIN_SRC conf :noweb-ref generated dependency inclusion

ifeq "$(strip $(include-deps))" "YES"
include ifupdown.d
endif

#+END_SRC

* Compile Time Configuration

At compile time we need to determine all the possible address families
that may be used, and all the methods of setting up interfaces for
those address families, along with the various possible options
affecting each method.

Our key definition at this point is that of the [[address_family]]
structure, which encapsulates all the compile time information about
each address family.

#+BEGIN_SRC C :noweb-ref type definitions
typedef struct address_family address_family;
#+END_SRC

#+BEGIN_SRC C :noweb-ref structure definitions
struct address_family {
	char *name;
	int n_methods;
	method *method;
};
#+END_SRC

Each defined address family will be included in the [[addr_fams]]
array, which becomes the \emph{raison d'\^etre} of the [[addrfam]]
module.

#+BEGIN_SRC C :noweb-ref exported symbols
extern address_family *addr_fams[];
#+END_SRC

Each address family incorporates a number of methods, which
encapsulate various ways of configuring an interface for a particular
address family. There are three components of a method: two sets of
commands to bring an interface up and down, a number of options for
the commands, and a set of conversion functions to allow programmatic
manipulation of the options.

#+BEGIN_SRC C :noweb-ref type definitions
typedef struct method method;
#+END_SRC

#+BEGIN_SRC C :noweb-ref structure definitions
struct method {
	char *name;
	command_set *up, *down;
	conversion *conversions;
	option_default *defaults;
};
#+END_SRC

Each command set is implemented as a single function, accepting two
parameters: the definitions of the interface the commands should deal
with, and the function that should be used to execute them. See the
[[execute]] module for more details.

#+BEGIN_SRC C :noweb-ref function type definitions
typedef int (execfn)(char *command);
typedef int (command_set)(interface_defn *ifd, execfn *e);
#+END_SRC

Each conversion is implemented as a mapping from an option name, to a
function that updates that option's value or adds a new variable which
value is the result of conversion, as follows:

#+BEGIN_SRC C :noweb-ref type definitions
typedef struct conversion conversion;
typedef struct option_default option_default;
#+END_SRC

#+BEGIN_SRC C :noweb-ref structure definitions
struct conversion {
	char *option;
	char *newoption;
	void (*fn)(interface_defn *, char **, int, char **);
	int argc;
	char ** argv;
};

struct option_default {
	char *option;
	char *value;
};
#+END_SRC

As our compile-time configuration is done at, well, compile-time, there
is little need for functions in the actual module, and we can make do with
a single exported array.

#+BEGIN_SRC C :tangle addrfam.c
#include <stdlib.h>
#include "header.h"

address_family *addr_fams[] = {
	<<address family references>>
	NULL
};

#+END_SRC

** TODO Generating C Code

Unfortunately, while the [[.defn]] representation is reasonably
convenient for human use, it's less convenient for a compiler. As
such, at build time, we will build a single structure of type
[[address_family]] in a separate module, and reference that from
[[addrfam.c]].

Naturally, we'll use a [[perl]] script to convert [[.defn]] files to C
code.

#+BEGIN_SRC conf :noweb-ref implicit rules
%.c : %.defn defn2c.pl
	./defn2c.pl $< > $@
#+END_SRC

The functionality of our program is pretty basic: read from the file
specified as the argument, output to [[stdout]]; and correspondingly
the structure of the program is similarly simple. We make use of a
couple of global variables, a few helpful subroutines, and then build
our C program.

#+BEGIN_SRC perl :tangle defn2c.pl
#!/usr/bin/perl -w

use strict;

<<determine the target architecture>>

# declarations
<<defn2c variables>>

# subroutines
<<defn2c subroutines>>

# main code
<<output headers for address family>>
<<parse [[.defn]] file and output intermediate structures>>
<<output address family data structure>>

#+END_SRC

First of all, we determine the target architecture by calling [[dpkg-architecture]] and stripping the trailing newline:

#+BEGIN_SRC perl :noweb-ref determine the target architecture
my $DEB_HOST_ARCH_OS = `dpkg-architecture -qDEB_HOST_ARCH_OS`;

$DEB_HOST_ARCH_OS =~ s/\n//;
#+END_SRC

# Around line 578...

** TODO Building Manual Pages
* TODO Run-time Configuration
** TODO File Handling
** TODO Line Parsing
** TODO Line Processing
*** TODO Source Line
*** TODO Mapping Line
*** TODO Interface line
*** TODO Auto and Allow Lines
** TODO Error Handling
* TODO Execution

** TODO Interface Configuration and Deconfiguration
*** TODO Command checking
*** TODO Environment handling

[[doit()]] is much more complicated, mainly by the fact that we
don't simply want to just run the programs, but because we also want
to setup a sanitized environment. In particular, we want to make the
environment variables [[IFACE]], and [[MODE]] available (eg, [[eth0]] and
[[start]] respectively), and we want to export all the given options as
[[IF_OPTION]], with some sanitisation.

We'll do this just once per interface rather than once per command,
and so we'll use a global variable to store our new environment, and a
special function which will initialise it for us.

#+BEGIN_SRC C :noweb-ref execute global variables
static char **environ = NULL;
#+END_SRC

[[environ]] will be in the format used by the [[execle()]] function call,
that is, a [[NULL]]-terminated array of strings of the form [[foo=bar]].

#+BEGIN_SRC C :noweb-ref execute function declarations
static void set_environ(interface_defn *iface, char *mode, char *phase);
#+END_SRC

Our function then will be:

#+BEGIN_SRC C :noweb-ref execute functions
static void set_environ(interface_defn *iface, char *mode, char *phase) {
	<<variables local to set environ>>
	int i;
	const int n_env_entries = iface->n_options + 8;

	<<initialise environ [[n_env_entries]]>>

	for (i = 0; i < iface->n_options; i++) {
		<<[[continue]] if option is a command>>

		<<add [[IF_]]option to environment>>
	}

	<<add [[IFACE]] to environment>>
	<<add [[LOGICAL]] to environment>>
	<<add [[ADDRFAM]] to environment>>
	<<add [[METHOD]] to environment>>

	<<add [[MODE]] to environment>>
	<<add [[PHASE]] to environment>>
	<<add [[VERBOSITY]] to environment>>

	<<add [[PATH]] to environment>>
}
#+END_SRC

Since we keep adding at the end, we'll make use of a pointer to keep track
of where the end actually is, namely:

#+BEGIN_SRC C :noweb-ref variables local to set environ
char **environend;
#+END_SRC

Initialising thus becomes:

#+BEGIN_SRC C :noweb-ref initialise environ [[n_env_entries]]
<<clear environ if necessary>>
environ = malloc(sizeof(char*) * (n_env_entries + 1 /* for final NULL */));
environend = environ; 
*environend = NULL;
#+END_SRC

#+BEGIN_SRC C :noweb-ref clear environ if necessary
{
	char **ppch;
	if (environ != NULL) {
		for (ppch = environ; *ppch; ppch++) {
			free(*ppch);
			*ppch = NULL;
		}
		free(environ);
		environ = NULL;
	}
}
#+END_SRC

Our continue chunk is also fairly straight forward:

#+BEGIN_SRC C :noweb-ref [[continue]] if option is a command
if (strcmp(iface->option[i].name, "pre-up") == 0
    || strcmp(iface->option[i].name, "up") == 0
    || strcmp(iface->option[i].name, "down") == 0
    || strcmp(iface->option[i].name, "post-down") == 0)
{
	continue;
}
#+END_SRC

We'll make use of a small helper function for actually setting the
environment. This function will handle [[malloc]]ing enough memory, and
ensuring the environment variable name is reasonably sensible. It'll
take three parameters: a [[printf]]-style format string presumed to
contain two [[%s]]s, and the two parameters to that format string.

#+BEGIN_SRC C :noweb-ref execute function declarations
static char *setlocalenv(char *format, char *name, char *value);
#+END_SRC

We can then go ahead and fill in the environment.

#+BEGIN_SRC C :noweb-ref add [[IF_]]option to environment
*(environend++) = setlocalenv("IF_%s=%s", iface->option[i].name,
                              iface->option[i].value ? iface->option[i].value : "");
*environend = NULL;
#+END_SRC

#+BEGIN_SRC C :noweb-ref add [[IFACE]] to environment
*(environend++) = setlocalenv("%s=%s", "IFACE", iface->real_iface);
*environend = NULL;
#+END_SRC

#+BEGIN_SRC C :noweb-ref add [[LOGICAL]] to environment
*(environend++) = setlocalenv("%s=%s", "LOGICAL", iface->logical_iface);
*environend = NULL;
#+END_SRC

#+BEGIN_SRC C :noweb-ref add [[MODE]] to environment
*(environend++) = setlocalenv("%s=%s", "MODE", mode);
*environend = NULL;
#+END_SRC

#+begin_src C :noweb-ref add [[PHASE]] to environment
*(environend++) = setlocalenv("%s=%s", "PHASE", phase); 
*environend = NULL;
#+end_src

#+begin_src C :noweb-ref add [[PATH]] to environment
*(environend++) = setlocalenv("%s=%s", "PATH", "/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin");
*environend = NULL;
#+end_src

#+begin_src C :noweb-ref add [[VERBOSITY]] to environment
*(environend++) = setlocalenv("%s=%s", "VERBOSITY", verbose ? "1" : "0");
*environend = NULL;
#+end_src

#+begin_src C :noweb-ref add [[ADDRFAM]] to environment
*(environend++) = setlocalenv("%s=%s", "ADDRFAM", iface->address_family->name);
*environend = NULL;
#+end_src

#+begin_src C :noweb-ref add [[METHOD]] to environment
*(environend++) = setlocalenv("%s=%s", "METHOD", iface->method->name);
*environend = NULL;
#+end_src

Our helper function then will then be something like:

#+BEGIN_SRC C :noweb-ref execute functions
static char *setlocalenv(char *format, char *name, char *value) {
	char *result;

	<<allocate memory for [[result]]>>

	sprintf(result, format, name, value);

	<<tidy [[result]]>>

	return result;
}
#+END_SRC

Allocating the memory is fairly straightforward (although working out
exactly how much memory involves a little guesswork, and assuming the
caller passes in a reasonable [[format]]).

#+BEGIN_SRC C :noweb-ref allocate memory for [[result]]
result = malloc(strlen(format)   /* -4 for the two %s's */
                + strlen(name) 
                + strlen(value) 
                + 1);
if (!result) {
	perror("malloc");
	exit(1);
}
#+END_SRC

And finally, tidying the result is a fairly simple matter of eliding all
the characters we don't like, or translating them to ones we do like. We
do like upper case letters, digits and underscores; and we're willing
to translate hyphens and lower case letters. So here we go.

#+BEGIN_SRC C :noweb-ref tidy [[result]]
{
	char *here, *there;

	for(here = there = result; *there != '=' && *there; there++) {
		if (*there == '-') *there = '_';
		if (isalpha(*there)) *there = toupper(*there);

		if (isalnum(*there) || *there == '_') {
			*here = *there;
			here++;
		}
	}
	memmove(here, there, strlen(there) + 1);
}
#+END_SRC

*** TODO Command Execution

Our [[doit()]] function is then essentially a rewrite of the standard
[[system()]] function call. The only additions are that we setup our
child's environment as discussed previously, and we make use of two
external globals, [[no_act]] and [[verbose]] and modify our behaviour
based on those.

#+BEGIN_SRC C :noweb-ref exported symbols
int doit(char *str);
#+END_SRC

#+BEGIN_SRC C :noweb-ref execute functions
int doit(char *str) {
	assert(str);
	bool ignore_status = false;
	if (*str == '-') {
	    ignore_status = true;
	    str++;
	}

	if (verbose || no_act) {
		fprintf(stderr, "%s\n", str);
	}
	if (!no_act) {
		pid_t child;
		int status;

		fflush(NULL);
		setpgid(0, 0);
		switch(child = fork()) {
		    case -1: /* failure */
			return 0;
		    case 0: /* child */
			execle("/bin/sh", "/bin/sh", "-c", str, NULL, environ);
			exit(127);
		    default: /* parent */
		    	break;
		}
		waitpid(child, &status, 0);
		if (ignore_status)
			return 1;

		if (!WIFEXITED(status) || WEXITSTATUS(status) != 0)
			return 0;
	}
	return 1;
}
#+END_SRC

*** TODO Executing a list of commands

In addition to the above, we also need a function to cope with running
all the [[pre-up]] commands and so forth.

#+BEGIN_SRC C :noweb-ref exported symbols
int execute_options(interface_defn *ifd, execfn *exec, char *opt);
int execute_scripts(interface_defn *ifd, execfn *exec, char *opt);
#+END_SRC

All we need to do for this is to iterate through the options in the
interface definition, and execute whichever ones are the right type,
and call the [[run-parts]] command on the appropriate directory of
scripts. That doesn't make for thrilling code.

This function will generally have [[doit]] passed in as the [[exec]]
parameter.

#+BEGIN_SRC C :noweb-ref execute functions

int execute_options(interface_defn *ifd, execfn *exec, char *opt) {
	int i;
	for (i = 0; i < ifd->n_options; i++) {
		if (strcmp(ifd->option[i].name, opt) == 0) {
			if (!(*exec)(ifd->option[i].value)) {
				return 0;
			}
		}
	}
	return 1;
}

int execute_scripts(interface_defn *ifd, execfn *exec, char *opt) {
	if (!run_scripts) return 1;

	char buf[100];
	snprintf(buf, sizeof(buf), "run-parts %s /etc/network/if-%s.d",
		verbose ? "--verbose" : "", opt);

	(*exec)(buf); 

	return 1;
}

#+END_SRC
*** TODO [[iface_up()]], [[iface_down()]], [[iface_list()]], and [[iface_query()]]

Our functions, then are:

#+BEGIN_SRC C :noweb-ref exported symbols
int iface_preup(interface_defn *iface);
int iface_postup(interface_defn *iface);
int iface_up(interface_defn *iface);
int iface_predown(interface_defn *iface);
int iface_postdown(interface_defn *iface);
int iface_down(interface_defn *iface);
int iface_list(interface_defn *iface);
int iface_query(interface_defn *iface);
#+END_SRC

#+BEGIN_SRC C :noweb-ref execute functions

int iface_preup(interface_defn *iface) {
	if (!iface->method->up(iface,check)) return -1;

	set_environ(iface, "start", "pre-up");
	if (!execute_options(iface,doit,"pre-up")) return 0;
	if (!execute_scripts(iface,doit,"pre-up")) return 0;

	return 1;
}

int iface_postup(interface_defn *iface) {
	if (!iface->method->up(iface,doit)) return 0;

	set_environ(iface, "start", "post-up");
	if (!execute_options(iface,doit,"up")) return 0;
	if (!execute_scripts(iface,doit,"up")) return 0;

	return 1;
}

int iface_up(interface_defn *iface) {
	int result = iface_preup(iface);
	if (result != 1) return result;
	return iface_postup(iface);
}

#+END_SRC

When bringing interface down, we check if there's [[ifup]] is still running
and send [[SIGTERM]] to terminate it.

#+BEGIN_SRC C :noweb-ref terminate ifup if it is still running
char pidfilename[100];
snprintf(pidfilename, sizeof(pidfilename), RUN_DIR "ifup-%s.pid",
	iface->real_iface);
FILE * pidfile = fopen(pidfilename, "r");
if (pidfile) {
	int pid;
	if (fscanf(pidfile, "%d", &pid)) {
		if (verbose) {
			fprintf(stderr, "Terminating ifup (pid %d)\n", pid);
		}
		kill((pid_t) -pid, SIGTERM);
	}
	fclose(pidfile);
	unlink(pidfilename);
}

#+END_SRC

#+BEGIN_SRC C :noweb-ref execute functions

int iface_predown(interface_defn *iface) {
	if (!no_act) {
	    <<terminate ifup if it is still running>>
	}

	if (!iface->method->down(iface,check)) return -1;

	set_environ(iface, "stop", "pre-down");
	if (!execute_scripts(iface,doit,"down")) return 0;
	if (!execute_options(iface,doit,"down")) return 0;

	return 1;
}

int iface_postdown(interface_defn *iface) {
	if (!iface->method->down(iface,doit)) return 0;

	set_environ(iface, "stop", "post-down");
	if (!execute_scripts(iface,doit,"post-down")) return 0;
	if (!execute_options(iface,doit,"post-down")) return 0;

	return 1;
}

int iface_down(interface_defn *iface) {
	int result = iface_predown(iface);
	if (result != 1) return result;
	return iface_postdown(iface);
}

#+END_SRC

#+BEGIN_SRC C :noweb-ref execute functions

int iface_list(interface_defn *iface) {
	printf("%s\n",iface->real_iface);
	return 0;
}

#+END_SRC

#+BEGIN_SRC C :noweb-ref execute functions

int iface_query(interface_defn *iface) {
	int i;
	for (i = 0; i < iface->n_options; i++) {
		printf("%s: %s\n",iface->option[i].name, iface->option[i].value);
	}
	return 0;
}

#+END_SRC
** TODO Command Parsing

All the above just leave one thing out: how the address family method's
configuration function gets back to calling [[doit()]]. This function
answers that question:

#+BEGIN_SRC C :noweb-ref exported symbols
int execute(char *command, interface_defn *ifd, execfn *exec);
#+END_SRC

At the somewhat abstract level, this is fairly trivial. The devil is
in the details of the parsing, which makes up the rest of the module.

#+BEGIN_SRC C :noweb-ref exported functions

int execute(char *command, interface_defn *ifd, execfn *exec) { 
	char *out;
	int ret;

	out = parse(command, ifd);
	if (!out) { return 0; }

	ret = (*exec)(out);

	free(out);
	return ret;
}

#+END_SRC

*** TODO Maintain output buffer
*** TODO Escaped characters
*** TODO Optional components
*** TODO Variables
** TODO Mapping Scripts
* TODO The Driver

** TODO Check the Environment
** TODO Configuring or Deconfiguring?

So the very first real thing we need to do is parse the command name. To
do this, we'll obviously need to work out somewhere to store the result. A
reasonable thing to do here is just to keep a function pointer about,
which will point to one of the previously defined [[iface_up]] or
[[iface_down]] functions, depending on which should be used on the
specified interfaces.

#+BEGIN_SRC C :noweb-ref variables local to main
int (*cmds)(interface_defn *) = NULL;
#+END_SRC

So given this, we can just:

#+BEGIN_SRC C :noweb-ref parse command name or die
{
	char *command;

	<<set [[command]] to the base of the command name>>
	<<set [[cmds]] based on [[command]] or die>>
}
#+END_SRC

And fill out each component in the reasonably obvious manner of:

#+BEGIN_SRC C :noweb-ref set [[command]] to the base of the command name
if ((command = strrchr(argv[0],'/'))) {
	command++; /* first char after / */
} else {
	command = argv[0]; /* no /'s in argv[0] */
}
#+END_SRC

#+BEGIN_SRC C :noweb-ref set [[cmds]] based on [[command]] or die
if (strcmp(command, "ifup")==0) {
	cmds = iface_up;
} else if (strcmp(command, "ifdown")==0) {
	cmds = iface_down;
} else if (strcmp(command, "ifquery")==0) {
	cmds = iface_query;
	no_act = 1;
} else {
	fprintf(stderr,"This command should be called as ifup, ifdown, or ifquery\n");
	exit(1);
}
#+END_SRC

In addition, since our later behaviour varies depending on whether we're
bringing interfaces up, taking them down, or querying /etc/network/interfaces,
we'll define four chunks to assist with this, namely:

#+BEGIN_SRC C :noweb-ref we're querying an interface's config
(cmds == iface_query)
#+END_SRC

#+BEGIN_SRC C :noweb-ref we're listing known interfaces
(cmds == iface_list)
#+END_SRC

#+BEGIN_SRC C :noweb-ref we're bringing interfaces up
(cmds == iface_up)
#+END_SRC

#+BEGIN_SRC C :noweb-ref we're taking interfaces down
(cmds == iface_down)
#+END_SRC

The [[--allow]] option lets us limit the interfaces ifupdown will act on.
It's implemented by having an [[allow_class]] that tells us which class
of interfaces we're working with, and skipping interfaces that aren't
in that class, like so:

#+BEGIN_SRC C :noweb-ref we're limiting to [[--allow]]ed interfaces
(allow_class != NULL)
#+END_SRC

#+BEGIN_SRC C :noweb-ref find [[iface]] in [[allow_class]] or [[continue]]
{
	int i;
	allowup_defn *allowup = find_allowup(defn, allow_class);
	if (allowup == NULL)
		continue;

	for (i = 0; i < allowup->n_interfaces; i++) {
		if (strcmp(allowup->interfaces[i], iface) == 0)
			break;
	}
	if (i >= allowup->n_interfaces)
		continue;
}
#+END_SRC

Finally, the behaviour might vary depending on whether we are 
excluding this interface or not. Notice that
the exclude option can use a full interface name or substrings that
match interfaces. A user could easily have unexpected behaviour
if he uses a small string to do the match:

#+BEGIN_SRC C :noweb-ref we're [[--exclude]]ing this interface
(excludeints != 0 && match_patterns(iface, excludeints, excludeint))
#+END_SRC

[[match_patterns]] function goes through exclusion patterns and returns [[true]] if it finds at least one match.

#+BEGIN_SRC C :noweb-ref main function declarations
bool match_patterns(char * string, int argc, char * argv[]);
#+END_SRC

It's implemented using [[fnmatch]] function, so we can use shell globs.

#+BEGIN_SRC C :noweb-ref main functions
bool match_patterns(char * string, int argc, char * argv[]) {
	if (!argc || !argv || !string) return false;
	int i;
	for (i = 0; i < argc; i++) {
		if (fnmatch(argv[i], string, 0) == 0) {
			return true;
		}
	}
	return false;
}
#+END_SRC

** TODO Argument Handling
** TODO Reading the Interfaces File
** TODO Execution

A broad overview of what we'll actually be doing is as follows:

#+BEGIN_SRC C :noweb-ref run commands for appropriate interfaces
<<determine target interfaces>>
<<run pre-up and pre-down scripts for all>>
{
	int i;
	for (<<each target interface, [[i]]>>) {
		char iface[80], liface[80];
		const char *current_state;

		<<initialize [[iface]] to [[i]]th target interface>>
		current_state = read_state(argv[0], iface);
		if (!force) {
			<<check ifupdown state (possibly [[continue]])>>
		}

		if (<<we are limiting to [[--allow]]ed interfaces>>) {
			<<find [[iface]] in [[allow_class]] or [[continue]]>>
		}

		if (<<we are [[--exclude]]ing this interface>>)  
			continue;

		bool have_mapping = false;
		if ((<<we are bringing interfaces up>> && run_mappings) || <<we are querying an interface's config>>) {
			<<run mappings>>
		}

		<<bring interface up/down and update ifupdown state>>
	}
}
<<run post-up and post-down scripts for all>>
#+END_SRC

We'll leave determining the appropriate target interfaces and dealing
with the state until a little later. That leaves us with covering running
the mappings and bringing the interface up or taking it down.

Mappings are dealt with like so:

#+BEGIN_SRC C :noweb-ref run mappings
{
	mapping_defn *currmap;
	for (currmap = defn->mappings; currmap; currmap = currmap->next) {
		int i;
		for (i = 0; i < currmap->n_matches; i++) {
			<<[[continue]] unless mapping matches>>
			<<run mapping>>
			break;
		}
	}
}
#+END_SRC

We check if mappings match by using shell globs, so we'll need a new header
to take care of that.

#+BEGIN_SRC C :noweb-ref main headers
#include <fnmatch.h>
#+END_SRC

#+BEGIN_SRC C :noweb-ref [[continue]] unless mapping matches
if (fnmatch(currmap->match[i], liface, 0) != 0)
	continue;
#+END_SRC

Actually running a mapping is fairly straightforward, thanks to our
previous handywork.

#+BEGIN_SRC C :noweb-ref run mapping
if (<<we are querying an interface's config>> && !run_mappings) {
	if (verbose) {
		fprintf(stderr, "Not running mapping scripts for %s\n",
			liface);
	}
	have_mapping = true;
	break;
}
if (verbose) {
	fprintf(stderr, "Running mapping script %s on %s\n",
		currmap->script, liface);
}
run_mapping(iface, liface, sizeof(liface), currmap);
#+END_SRC

Bringing an interface up or taking it down can be done thusly:

#+BEGIN_SRC C :noweb-ref bring interface up/down and update ifupdown state
{
	interface_defn *currif;
	int okay = 0;
	int failed = 0; 

	<<update ifupdown state>>

	if (<<we are listing known interfaces>>) {
	    for (currif = defn->ifaces; currif; currif = currif->next) {
		    if (strcmp(liface, currif->logical_iface) == 0) {
			okay = 1;
		    }
	    }
	    if (!okay) {
		    mapping_defn *currmap;
		    for (currmap = defn->mappings; currmap; currmap = currmap->next) {
			    int i;
			    for (i = 0; i < currmap->n_matches; i++) {
				    <<[[continue]] unless mapping matches>>
				    okay = 1;
				    break;
			    }
		    }
	    }
	    if (okay) {
		    currif = defn->ifaces;
		    currif->real_iface = iface;
		    cmds(currif);
		    currif->real_iface = NULL;
	    }
	    okay = 0;
	    continue;
	}

	for (currif = defn->ifaces; currif; currif = currif->next) {
		if (strcmp(liface, currif->logical_iface) == 0) {
			<<configure the link>>
			okay = 1;

			<<add default options to [[currif]]>>

			<<add options from command line to [[currif]]>>

			currif->real_iface = iface;

			<<convert options>>

			<<run commands for [[currif]]; set [[failed]] on error>>

			currif->real_iface = NULL;

			if (failed) break;
			/* Otherwise keep going: this interface may have
			 * match with other address families */
		}
	}

	<<deconfigure the link>>

	if (!okay && <<we are querying an interface's config>>) {
		if (!run_mappings) {
			if (have_mapping) {
				okay = 1;
			}
		}
		if (!okay) {
			<<report unknown interface and die>>
		}
	}

	if (!okay && !force) {
		fprintf(stderr, "Ignoring unknown interface %s=%s.\n", 
			iface, liface);
		update_state (argv[0], iface, NULL);
	} else {
		<<update ifupdown state>>
	}
}
#+END_SRC

#+BEGIN_SRC C :noweb-ref configure the link
	if (!okay && <<we are bringing interfaces up>>) {
		interface_defn link = {
		    .real_iface = iface,
		    .logical_iface = liface,
		    .max_options = 0,
		    .address_family = &addr_link,
		    .method = &(addr_link.method[0]),
		    .n_options = 0,
		    .option = NULL
		};
		convert_variables(argv[0], link.method->conversions, &link);

		if (!link.method->up(&link, doit)) break;
		if (link.option) free(link.option);
	}
#+END_SRC

#+BEGIN_SRC C :noweb-ref deconfigure the link
	if (okay && <<we are taking interfaces down>>) {
		interface_defn link = {
		    .real_iface = iface,
		    .logical_iface = liface,
		    .max_options = 0,
		    .address_family = &addr_link,
		    .method = &(addr_link.method[0]),
		    .n_options = 0,
		    .option = NULL
		};
		convert_variables(argv[0], link.method->conversions, &link);

		if (!link.method->down(&link, doit)) break;
		if (link.option) free(link.option);
	}
#+END_SRC

#+BEGIN_SRC C :noweb-ref create pidfile
{
	char * command;
	<<set [[command]] to the base of the command name>>
	snprintf(pidfilename, sizeof(pidfilename), RUN_DIR "%s-%s.pid",
		command, currif->real_iface);
	if (!no_act) {
		FILE * pidfile = fopen(pidfilename, "w");
		if (pidfile) {
			fprintf(pidfile, "%d", getpid());
			fclose(pidfile);
		} else {
			fprintf(stderr, 
				"%s: failed to open pid file %s: %s\n",
				command, pidfilename, strerror(errno));
		}
	}
}
#+END_SRC

#+BEGIN_SRC C :noweb-ref remove pidfile
	if (!no_act) {
		unlink(pidfilename);
	}
#+END_SRC

#+BEGIN_SRC C :noweb-ref run commands for [[currif]]; set [[failed]] on error
{
	if (verbose) {
		fprintf(stderr, "%s interface %s=%s (%s)\n", 
			<<we are querying an interface's config>> ? "Querying" :
			"Configuring",
			iface, liface, currif->address_family->name);
	}

	char pidfilename[100];
	<<create pidfile>>

	switch(cmds(currif)) {
	    case -1:
		fprintf(stderr, "Missing required configuration variables for interface %s/%s.\n", 
			liface, currif->address_family->name);
		failed = 1;
		break;
	    case 0:
		failed = 1;
		break;
		/* not entirely successful */
	    case 1:
	    	failed = 0;
		break;
		/* successful */
	    default:
	    	fprintf(stderr, "Unexpected value when configuring interface %s/%s; considering it failed.\n", 
			liface, currif->address_family->name);
	    	failed = 1;
		/* what happened here? */
	}

	<<remove pidfile>>
}
#+END_SRC

Before bringing interfaces up or putting them down, we may want to call some
scripts interested in being notified when all the interfaces are going to
be brought up:

#+BEGIN_SRC C :noweb-ref run pre-up and pre-down scripts for all
interface_defn meta_iface = {
    .next = NULL,
    .real_iface = "--all",
    .address_family = &addr_meta,
    .method = &(addr_meta.method[0]),
    .automatic = 1,
    .max_options = 0,
    .n_options = 0,
    .option = NULL
};

if (do_all) {
    meta_iface.logical_iface = allow_class ? allow_class : "auto";

    int okay = 1;
    if (<<we are bringing interfaces up>>) {
	okay = iface_preup(&meta_iface);
    }
    if (<<we are taking interfaces down>>) {
	okay = iface_predown(&meta_iface);
    }
    if (!okay) {
	fprintf(stderr, "%s: pre-%s script failed.\n", argv[0], &argv[0][2]);
	exit(1);
    }
}
#+END_SRC

#+BEGIN_SRC C :noweb-ref run post-up and post-down scripts for all
if (do_all) {
    int okay = 1;
    if (<<we are bringing interfaces up>>) {
	okay = iface_postup(&meta_iface);
    }
    if (<<we are taking interfaces down>>) {
	okay = iface_postdown(&meta_iface);
    }
    if (!okay) {
	fprintf(stderr, "%s: post-%s script failed.\n", argv[0], &argv[0][2]);
	exit(1);
    }
}
#+END_SRC

Before adding any options from the command line we set the default options if
they've not been set already:

#+BEGIN_SRC C :noweb-ref add default options to [[currif]]
{
	option_default *o;
	for (o = currif->method->defaults; o && o->option && o->value; o++) {
		int j;
		int found = 0;
		for (j = 0; j < currif->n_options; j++) {
			if (strcmp(currif->option[j].name, 
			           o->option) == 0) 
			{
				found = 1;
				break;
			}
		}
		if (!found) {
			set_variable(argv[0], o->option, o->value,
				&currif->option, &currif->n_options, 
				&currif->max_options);
		}
	}
}
#+END_SRC

Adding the options from the command line is tedious, but simple:

#+BEGIN_SRC C :noweb-ref add options from command line to [[currif]]
{
	int i;
	for (i = 0; i < n_options; i++) {
		if (option[i].value[0] == '\0') {
			<<remove [[option[i]]] from [[currif]]>>
		} else {
			<<add [[option[i]]] to [[currif]]>>
		}
	}
}
#+END_SRC

Convert the options:

#+BEGIN_SRC C :noweb-ref convert options
{
	convert_variables(argv[0], currif->method->conversions, currif);
}
#+END_SRC

#+BEGIN_SRC C :noweb-ref add [[option[i]]] to [[currif]]
{
	set_variable(argv[0], option[i].name, option[i].value,
		&currif->option, &currif->n_options, 
		&currif->max_options);
}
#+END_SRC

#+BEGIN_SRC C :noweb-ref remove [[option[i]]] from [[currif]]
{
	if (strcmp(option[i].name, "pre-up") != 0
    	    && strcmp(option[i].name, "up") != 0
	    && strcmp(option[i].name, "down") != 0
	    && strcmp(option[i].name, "post-down") != 0)
	{
		int j;
		for (j = 0; j < currif->n_options; j++) {
			if (strcmp(currif->option[j].name, 
			           option[i].name) == 0) 
			{
				currif->n_options--;
				break;
			}
		}
		for (; j < currif->n_options; j++) {
			option[j].name = option[j+1].name;
			option[j].value = option[j+1].value;
		}
	} else {
		/* do nothing */
	}
}
#+END_SRC

** TODO Target Interfaces

So, if we're going to actually do something, we should probably figure
out exactly what we're going to do it to. So, we need to know the set
of interfaces we're going to hax0r. This is just an array of interfaces,
either [[physical_iface]] or [[physical_iface=logical_iface]].

#+BEGIN_SRC C :noweb-ref variables local to main
int n_target_ifaces;
char **target_iface;
#+END_SRC

#+BEGIN_SRC C :noweb-ref each target interface, [[i]]
i = 0; i < n_target_ifaces; i++
#+END_SRC

We initialise this based on our command line arguments.

#+BEGIN_SRC C :noweb-ref determine target interfaces
if (do_all || list) {
	if (<<we are listing known interfaces>>
            || <<we are bringing interfaces up>>) {
		allowup_defn *autos = find_allowup(defn, allow_class ? allow_class : "auto");
		target_iface = autos ? autos->interfaces : NULL;
		n_target_ifaces = autos ? autos->n_interfaces : 0;
	} else if (<<we are taking interfaces down>>) {
		read_all_state(argv[0], &target_iface, &n_target_ifaces);
	} else {
		fprintf(stderr, "%s: can't tell if interfaces are going up or down\n", argv[0]);
		exit(1);
	}	
} else {
	target_iface = argv + optind;
	n_target_ifaces = argc - optind;
}
#+END_SRC

#+BEGIN_SRC C :noweb-ref initialize [[iface]] to [[i]]th target interface
strncpy(iface, target_iface[i], sizeof(iface));
iface[sizeof(iface)-1] = '\0';

{
	char *pch;
	if ((pch = strchr(iface, '='))) {
		*pch = '\0';
		strncpy(liface, pch+1, sizeof(liface));
		liface[sizeof(liface)-1] = '\0';
	} else {
		strncpy(liface, iface, sizeof(liface));
		liface[sizeof(liface)-1] = '\0';
	}
}
#+END_SRC

** TODO State

Since it's generally not feasible to rerun a mapping script after an
interface is configured (since a mapping script may well bring the
interface down while it's investigating matters), we need to maintain a
statefile between invocations to keep track of which physical interfaces
were mapped to which logical ones.  This file also serves to record
which interfaces have been configured so far, and which haven't.  It
is stored in [[/run/network/ifstate]].

Because different interfaces may be brought up and down at the same time,
it's important that all updates to the state file are atomic and that we
aren't confused by any changes made by another running process.  For this
reason we use functions to examine or modify the state file at the point
necessary rather than holding it all in memory.

* TODO Architecture-dependent functions

** TODO Common functions

#+BEGIN_SRC C :noweb-ref common functions declarations
#include "header.h"

int execable(char *);
#define iface_is_link() (!_iface_has(ifd->real_iface, ":."))
#define iface_has(s) _iface_has(ifd->real_iface, (s))
#define iface_is_lo() ((!strcmp(ifd->logical_iface, LO_IFACE)) && (!no_loopback))
int _iface_has(char *, char *);
void cleanup_hwaddress(interface_defn *ifd, char **pparam, int argc, char ** argv);
void make_hex_address(interface_defn *ifd, char **pparam, int argc, char ** argv);
void compute_v4_addr(interface_defn *ifd, char **pparam, int argc, char ** argv);
void compute_v4_mask(interface_defn *ifd, char **pparam, int argc, char ** argv);
void compute_v4_broadcast(interface_defn *ifd, char **pparam, int argc, char ** argv);
void set_preferred_lft(interface_defn *ifd, char **pparam, int argc, char ** argv);
void get_token(interface_defn *ifd, char **pparam, int argc, char ** argv);
void to_decimal(interface_defn *ifd, char **pparam, int argc, char ** argv);
void map_value(interface_defn *ifd, char **pparam, int argc, char ** argv);
#+END_SRC

#+BEGIN_SRC C :noweb-ref common functions implementations
#ifdef __GNUC__
#define UNUSED __attribute__((unused))
#else
#define UNUSED
#endif

int _iface_has(char *iface, char *delims) {
	char _iface[80];
	strncpy(_iface, iface, sizeof(_iface));
	_iface[sizeof(_iface) - 1] = 0;
	strtok(_iface, delims);
	void * token = strtok(NULL, delims);
	return (token != NULL);
}

int execable(char *program) {
	struct stat buf;

	if (0 == stat(program, &buf)) {
		if (S_ISREG(buf.st_mode) && (S_IXUSR & buf.st_mode)) return 1;
	}
	return 0;
}

void cleanup_hwaddress(interface_defn *ifd UNUSED, char **pparam, int argc UNUSED, char ** argv UNUSED) {
	char *rest = *pparam;
		/* we're shrinking the text, so no realloc needed */
	char *space = strchr(rest, ' ');

	if (space == NULL)
		return;

	*space = '\0';
	if (strcasecmp(rest, "ether") == 0 ||
		strcasecmp(rest, "ax25") == 0 ||
		strcasecmp(rest, "ARCnet") == 0 ||
		strcasecmp(rest, "netrom") == 0)
	{
		/* found deprecated <class> attribute */
		memmove(rest, space+1, strlen(space+1)+1);
	} else {
		*space = ' ';
	}
}

void make_hex_address(interface_defn *ifd UNUSED, char **pparam, int argc UNUSED, char ** argv UNUSED)
{
	char addrcomp[4];
	int maxlen = strlen("0000:0000");

	int ret = sscanf(*pparam, "%3hhu.%3hhu.%3hhu.%3hhu",
		&addrcomp[0], &addrcomp[1], &addrcomp[2], &addrcomp[3]);

	if (ret != 4)
		return;

	*pparam = realloc(*pparam, maxlen + 1);
	if (*pparam == NULL) return;
	snprintf(*pparam, maxlen + 1, "%.2hhx%.2hhx:%.2hhx%.2hhx",
		addrcomp[0], addrcomp[1], addrcomp[2], addrcomp[3]);
}

#include <arpa/inet.h>

void compute_v4_addr(interface_defn *ifd UNUSED, char **pparam, int argc UNUSED, char ** argv UNUSED)
{
	char s[INET_ADDRSTRLEN * 2 + 2]; /* 2 is for slash and \0 */
	strncpy(s, *pparam, sizeof(s));
	s[sizeof(s) - 1] = 0;

	char * token = strtok(s, "/");
	if (!token) return;

	*pparam = realloc(*pparam, strlen(token) + 1);
	if (*pparam == NULL) return;
	strcpy(*pparam, token);
}

void compute_v4_mask(interface_defn *ifd UNUSED, char **pparam, int argc UNUSED, char ** argv UNUSED)
{
	char s[INET_ADDRSTRLEN * 2 + 2]; /* 2 is for slash and \0 */
	strncpy(s, *pparam, sizeof(s));
	s[sizeof(s) - 1] = 0;

	char * token = strtok(s, "/");
	if (!token) return;

	uint8_t addr[sizeof(struct in_addr)];
	struct in_addr mask;
	if (inet_pton(AF_INET, token, &addr) != 1) return;
	token = strtok(NULL, "/");
	int maskwidth = -1;
	if (!token) {
		if (addr[0] <= 127) {
		    maskwidth = 8;
		} else if ((addr[0] >= 128) && (addr[0] <= 191)) {
		    maskwidth = 16;
		} else if ((addr[0] >= 192) && (addr[0] <= 223)) {
		    maskwidth = 24;
		} else {
		    maskwidth = 32;
		}
	} else {
		switch (inet_pton(AF_INET, token, &mask)) {
			case -1:
				return;

			case 0:
				if (sscanf(token, "%d", &maskwidth) != 1) return;
		}
	}
	if (maskwidth != -1) {
		mask.s_addr = htonl(~((1L << (32 - maskwidth)) - 1));
	}

	if (inet_ntop(AF_INET, &mask, s, sizeof(s)) == NULL) return;
	*pparam = realloc(*pparam, strlen(s) + 1);
	if (*pparam == NULL) return;
	strcpy(*pparam, s);
}

void compute_v4_broadcast(interface_defn *ifd, char **pparam, int argc UNUSED, char ** argv UNUSED)
{
	/* If we don't get special value don't do anything */
	if (strcmp(*pparam, "+") && strcmp(*pparam, "-")) return;

	struct in_addr addr;
	struct in_addr mask;

	char * s = get_var("address", strlen("address"), ifd);
	if (!s) return;
	int r = inet_pton(AF_INET, s, &addr);
	free(s);
	if (r != 1) return;

	s = get_var("netmask", strlen("netmask"), ifd);
	if (!s) return;
	r = inet_pton(AF_INET, s, &mask);
	free(s);
	if (r != 1) return;

	if (mask.s_addr != htonl(0xfffffffe)) {
	    if (!strcmp(*pparam, "+")) {
		addr.s_addr |= ~mask.s_addr;
	    }

	    if (!strcmp(*pparam, "-")) {
		addr.s_addr &= mask.s_addr;
	    }
	} else {
	    if (!strcmp(*pparam, "+")) {
		addr.s_addr = 0xffffffff;
	    }

	    if (!strcmp(*pparam, "-")) {
		addr.s_addr = 0;
	    }
	}

	char buffer[INET_ADDRSTRLEN + 1];
	if (inet_ntop(AF_INET, &addr, buffer, sizeof(buffer)) == NULL) return;
	*pparam = realloc(*pparam, strlen(buffer) + 1);
	if (*pparam == NULL) return;
	strcpy(*pparam, buffer);
}

void set_preferred_lft(interface_defn *ifd, char **pparam, int argc UNUSED, char ** argv UNUSED)
{
	if (!ifd->real_iface) return;
	if (iface_has(":")) {
		char s[] = "0";
		*pparam = realloc(*pparam, sizeof(s));
		if (*pparam == NULL) return;
		strcpy(*pparam, s);
	}
}

void get_token(interface_defn *ifd UNUSED, char **pparam, int argc, char ** argv)
{
	if (argc == 0) return;

	int token_no;
	if (argc == 1) {
		token_no = 0;
	} else {
		token_no = atoi(argv[1]);
	}

	char * s = strdup(*pparam);
	char * token = strtok(s, argv[0]);
	while (token_no > 0) {
		token = strtok(NULL, argv[0]);
		token_no--;
	}
	if (token) {
	    strcpy(*pparam, token);
	} else {
	    if (argc == 3) {
		*pparam = realloc(*pparam, strlen(argv[2]) + 1);
		if (*pparam == NULL) return;
		strcpy(*pparam, argv[2]);
	    }
	}
	free(s);
}

void to_decimal(interface_defn *ifd UNUSED, char **pparam, int argc, char ** argv)
{
	int base = 10;

	if (argc == 1) {
		base = atoi(argv[0]);
	}

	char * result;
	long value = strtol(*pparam, &result, base);
	if (result == *pparam) return;

	snprintf(*pparam, strlen(*pparam) + 1, "%ld", value);
}

void map_value(interface_defn *ifd UNUSED, char **pparam, int argc, char ** argv)
{
	if (argc < 2) return;

	int value;
	if (argc == 2) {
		value = (atoi(*pparam) ||
			strcasecmp(*pparam, "on") == 0 ||
			strcasecmp(*pparam, "true") == 0 ||
			strcasecmp(*pparam, "yes") == 0);
	}
	if ((value < argc) && (argv[value] != NULL)) {
		*pparam = realloc(*pparam, strlen(argv[value]) + 1);
		if (*pparam == NULL) return;
		strcpy(*pparam, argv[value]);
	} else {
		*pparam = realloc(*pparam, 1);
		if (*pparam == NULL) return;
		*pparam[0] = 0;
	}
}

#+END_SRC

** TODO Linux-specific functions

#+BEGIN_SRC C :tangle src/archlinux.h
unsigned int mylinuxver();
unsigned int mylinux(int,int,int);
<<common functions declarations>>
#+END_SRC

#+BEGIN_SRC C :tangle src/archlinux.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/utsname.h>
#include <sys/stat.h>

#include "archlinux.h"

unsigned int mylinuxver() {
	static int maj = -1, rev = 0, min = 0;

	if (maj == -1) {
		struct utsname u;
		char *pch;
		uname(&u);
		maj = atoi(u.release);
		pch = strchr(u.release, '.');
		if (pch) {
			rev = atoi(pch+1);
			pch = strchr(pch+1, '.');
			if (pch) {
				min = atoi(pch+1);
			}
		}
	}

	return mylinux(maj,rev,min);
}

unsigned int mylinux(int maj, int rev, int min) { 
	return min | rev << 10 | maj << 13;
}

<<common functions implementations>>
#+END_SRC

** TODO kFreeBSD-specific functions
** TODO Hurd-specific functions
* TODO Linux Address Families
** TODO IPv4 Address Family
** TODO IPv6 Address Family
** TODO IPX Address Family
** TODO CAN Address Family
* TODO kFreeBSD Address Families
** TODO IPv4 Address Family
** TODO IPv6 Address Family
* TODO Hurd Address Families
** TODO IPv4 Address Family
** TODO IPv6 Address Family
* TODO Internal address metafamily
* TODO Link pseudo address family
